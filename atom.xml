<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JhonYu&#39;s Blog</title>
  <subtitle>Victory Loves Preparation</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jiang-yu.cn/"/>
  <updated>2016-06-04T05:49:59.000Z</updated>
  <id>http://www.jiang-yu.cn/</id>
  
  <author>
    <name>Jiang Yu</name>
    <email>jhonyucoder@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> MySql InnoDB Lock(一)-- Shared and Exclusive Locks</title>
    <link href="http://www.jiang-yu.cn/2016/06/04/MySQL/InnoDB/InnoDB%20S&X%20Lock/"/>
    <id>http://www.jiang-yu.cn/2016/06/04/MySQL/InnoDB/InnoDB S&X Lock/</id>
    <published>2016-06-04T02:00:00.000Z</published>
    <updated>2016-06-04T05:49:59.000Z</updated>
    
    <content type="html">&lt;p&gt;　　InnoDB 引擎实现了两种标准的行级锁：共享锁(S锁)和排它锁(X锁),本篇就来介绍一下该类型的锁的相关信息。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###S Lock（共享锁） INTRODUCTION：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A shared (S) lock permits the transaction that holds the lock to read a row.&lt;br&gt;基本的意思为：在开启事务读一行数据的时候允许拥有一个共享锁，所以共享锁也称为读锁（read lock）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　如果事务T1拥有S锁，其他独立的事务也可以同时获取S锁，也就是说S锁是共享的。&lt;/p&gt;
&lt;p&gt;###X Lock（排它锁） INTRODUCTION：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An exclusive (X) lock permits the transaction that holds the lock to update or delete a row.&lt;br&gt;基本的意思是：在开启事务更新或者删除一行数据的时候允许有一个排它锁，所以排它锁也称为写锁（write lock）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　如果事务T1拥有X锁，其他独立的事务T2如果需要获得X锁必须要等待事务T1释放锁之后才能够得到。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　InnoDB 引擎实现了两种标准的行级锁：共享锁(S锁)和排它锁(X锁),本篇就来介绍一下该类型的锁的相关信息。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.jiang-yu.cn/categories/MySQL/"/>
    
    
      <category term="INNODB" scheme="http://www.jiang-yu.cn/tags/INNODB/"/>
    
      <category term="LOCK" scheme="http://www.jiang-yu.cn/tags/LOCK/"/>
    
  </entry>
  
  <entry>
    <title> MySql InnoDB Lock(二)--Intention Locks</title>
    <link href="http://www.jiang-yu.cn/2016/06/04/MySQL/InnoDB/InnoDB%20Intention%20Lock/"/>
    <id>http://www.jiang-yu.cn/2016/06/04/MySQL/InnoDB/InnoDB Intention Lock/</id>
    <published>2016-06-04T02:00:00.000Z</published>
    <updated>2016-06-04T09:27:47.000Z</updated>
    
    <content type="html">&lt;p&gt;　　在上一篇的&lt;code&gt;Shared And Exclusive Locks&lt;/code&gt;中提及到InnoDB默认实现的是&lt;br&gt;&lt;code&gt;Row-Level Lock&lt;/code&gt;(行级锁)，同时InnoDB中也支持多种粒度类型的锁，本文介绍的&lt;code&gt;Intention Locks&lt;/code&gt;（意向锁）就是一个体现，意向锁的主要目的是表明当前事务将要或者正在对表中的记录加锁。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;　　在MySQL InnoDB引擎中的行级锁只有明确的指定主键的时候才会在被筛选记录(即：&lt;code&gt;where keyAttr(主键)=xxx&lt;/code&gt;)上执行Row Lock，否则将会执行&lt;br&gt;Table Lock.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;摘抄自：MySql Doc&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB supports multiple granularity locking which permits coexistence of row-level locks and locks on entire tables. To make locking at multiple granularity levels practical, additional types of locks called intention locks are used. Intention locks are table-level locks in InnoDB that indicate which type of lock (shared or exclusive) a transaction will require later for a row in that table. There are two types of intention locks used in InnoDB (assume that transaction T has requested a lock of the indicated type on table t):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概意思是：InnoDB引擎允许&lt;code&gt;Row Level&lt;/code&gt; 锁和&lt;code&gt;Table Level&lt;/code&gt; 锁 支持多粒度的锁,这种锁称作：&lt;code&gt;Intention Locks&lt;/code&gt;,Intention Locks（意向锁）是属于Table Lock,它包含了两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intention shared(&lt;em&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/em&gt;):&lt;br&gt;示例：Set an &lt;em&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/em&gt; Locks :&lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt;&lt;br&gt;&lt;strong&gt;说明&lt;/strong&gt;：事务在给一个数据行加共享锁之前必须先取得该表的IS锁&lt;/li&gt;
&lt;li&gt;Intention exclusive(&lt;em&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/em&gt;):&lt;br&gt;示例：Set an &lt;em&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/em&gt; Locks ：&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;&lt;br&gt;&lt;strong&gt;说明&lt;/strong&gt;：事务在个一个数据行加排它锁之前必须先取得该表的IX锁&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;br&gt;　　1.在一个事务获得表中一条记录的 &lt;em&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/em&gt; Lock 前必须首先获得一个&lt;em&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/em&gt; Lock 或者更强的锁在表上；&lt;br&gt;　　2.在一个事务获得表中一条记录的 &lt;em&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/em&gt; LocK 前必须先获得一个&lt;em&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/em&gt; Lock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;InnoDB的锁类型相容性矩阵：&lt;/p&gt;
&lt;p&gt; | 　　|   X    | IX  |  S  |  IS |&lt;br&gt; |:—:|:——:|:—:|:—:|:—:|&lt;br&gt; | X   |Conflict| Conflict | Conflict | Conflict |&lt;br&gt; | IX  |Conflict|Compatible| Conflict |Compatible|&lt;br&gt; | S   |Conflict| Conflict |Compatible|Compatible|&lt;br&gt; | IS  |Conflict|Compatible|Compatible|Compatible|&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个事务请求的锁模式和当前的锁兼容，InnoDB就将请求的锁授予给后开启的事务，否则后开启的事务就必须等待当前的锁释放才能获得锁。如果一个锁和一个存在的锁冲突了的并且一段时间都没有获取到锁的话，就会出现死锁（后面再介绍）的现象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;死锁定义&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A situation where different transactions are unable to proceed, because each holds a lock that the other needs. Because both transactions are waiting for a resource to become available, neither will ever release the locks it holds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;死锁的例子&lt;br&gt;&amp;gt;&lt;br&gt;首先，客户A开启一个事务，然后对某一行执 IS 锁&lt;br&gt;&lt;code&gt;START TRANSACTION;&lt;/code&gt;&lt;br&gt;&lt;code&gt;select * from child where id=1 LOCK IN SHARE MODE;&lt;/code&gt;&lt;br&gt;&lt;small&gt;&lt;strong&gt;说明&lt;/strong&gt;：取得&lt;strong&gt;IS&lt;/strong&gt;锁&lt;/small&gt;&lt;br&gt;然后，客户B又过来开启了另外一个事务：&lt;br&gt;&lt;code&gt;START TRANSACTION;&lt;/code&gt;&lt;br&gt;执行一个删除操作：&lt;br&gt;&lt;code&gt;DELETE FROM child where id = 1;&lt;/code&gt;&lt;br&gt;&lt;small&gt;&lt;strong&gt;说明&lt;/strong&gt;：此时由于需要&lt;strong&gt;X&lt;/strong&gt; 锁，这个锁不兼容客户A持有的&lt;strong&gt;S&lt;/strong&gt;锁，所以没有客户B没有获得&lt;strong&gt;X&lt;/strong&gt;锁，一直等待A释放&lt;strong&gt;S&lt;/strong&gt;锁，所以客户B就被一直阻塞&lt;/small&gt;&lt;br&gt;最后，客户A也执行删除操作：&lt;br&gt;&lt;code&gt;DELETE FROM child where id = 1;&lt;/code&gt;&lt;br&gt;说明：此时客户A也需要X锁，而客户B也在等待X锁，此时InnoDB对客户A产生了一个死锁错误，并且终止其等待X锁操作。&lt;br&gt;结果客户端B抛出死锁：&lt;br&gt;&lt;code&gt;ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;表级锁和行级锁的比较&lt;br&gt;&amp;gt;&lt;br&gt;1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。&lt;br&gt;2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　在上一篇的&lt;code&gt;Shared And Exclusive Locks&lt;/code&gt;中提及到InnoDB默认实现的是&lt;br&gt;&lt;code&gt;Row-Level Lock&lt;/code&gt;(行级锁)，同时InnoDB中也支持多种粒度类型的锁，本文介绍的&lt;code&gt;Intention Locks&lt;/code&gt;（意向锁）就是一个体现，意向锁的主要目的是表明当前事务将要或者正在对表中的记录加锁。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.jiang-yu.cn/categories/MySQL/"/>
    
    
      <category term="INNODB" scheme="http://www.jiang-yu.cn/tags/INNODB/"/>
    
      <category term="DEADLOCK" scheme="http://www.jiang-yu.cn/tags/DEADLOCK/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法整理</title>
    <link href="http://www.jiang-yu.cn/2016/06/03/Markdown/MarkDown%E8%AF%AD%E6%B3%95%E8%AE%A4%E8%AF%86/"/>
    <id>http://www.jiang-yu.cn/2016/06/03/Markdown/MarkDown语法认识/</id>
    <published>2016-06-03T00:08:58.000Z</published>
    <updated>2016-06-03T16:34:13.000Z</updated>
    
    <content type="html">&lt;p&gt;　　作为一名合格的程序猿，写文档是必需的，选择一款合适的编辑器就如同一个好的助手，Markdown就是一个好的选择，语法简洁，逼格高~~，如果你经常玩GitHub，就会知道我们用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面就是基于Markdwon语法的。下面就来学习一下Markdown的基本语法吧！&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Markdown-语法&quot;&gt;&lt;a href=&quot;#Markdown-语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown 语法&quot;&gt;&lt;/a&gt;Markdown 语法&lt;/h1&gt;&lt;p&gt;[TOC]&lt;br&gt;　　下面将从三个层次来展开讲解，首先是常用层次，就是我们平时用的最多的并且要牢牢记住的（就如写代码的第一步：基本语法的熟悉），然后是对于一些不常用的，但是有可能会用到的标记我们必须要有印象，用到的时候能够快速的回想起来，最后就是了解层次了，这些标记基本上很少用到，只是在特定的情况下可能用到，并且能够通过查阅资料使用即可。&lt;/p&gt;
&lt;h3 id=&quot;一、常用层次&quot;&gt;&lt;a href=&quot;#一、常用层次&quot; class=&quot;headerlink&quot; title=&quot;一、常用层次&quot;&gt;&lt;/a&gt;一、常用层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
--- 次阶标题
=== 高阶标题
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h1 id=&quot;和标题之间最好加一个空格&quot;&gt;&lt;a href=&quot;#和标题之间最好加一个空格&quot; class=&quot;headerlink&quot; title=&quot;和标题之间最好加一个空格&quot;&gt;&lt;/a&gt;和标题之间最好加一个空格&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;&lt;h1 id=&quot;代表标题的层级，最多为六级&quot;&gt;&lt;a href=&quot;#代表标题的层级，最多为六级&quot; class=&quot;headerlink&quot; title=&quot;代表标题的层级，最多为六级&quot;&gt;&lt;/a&gt;代表标题的层级，最多为六级&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;　　在文档的标题都是按照Markdown语法来编写的，一般在一级标题下面使用 [TOC] 后会自动的生成层级目录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 标签使用如下标记：&lt;br&gt; 　　标签:Markdown&lt;br&gt; 　　Tags:Markdown&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 &amp;gt; 表示引用， &amp;gt;&amp;gt; 表示引用里面再套一层引用，依次类推&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;图片&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语法：![Beautiful](&lt;a href=&quot;http://img1.imgtn.bdimg.com/it/u=2948830857,1878924554&amp;amp;fm=21&amp;amp;gp=0.jpg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://img1.imgtn.bdimg.com/it/u=2948830857,1878924554&amp;amp;fm=21&amp;amp;gp=0.jpg&lt;/a&gt; “测试图片”)&lt;br&gt;实例：&lt;img src=&quot;http://img1.imgtn.bdimg.com/it/u=2948830857,1878924554&amp;amp;fm=21&amp;amp;gp=0.jpg&quot; alt=&quot;Beautiful&quot; title=&quot;测试图片&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;code content&lt;/code&gt;,英文状态下的键盘的左上角~键即可输出”`”,连接三个中间输入代码，最后还是三个结束,如果是显示的是行内代码就用”``”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语法：这就是我们常用的地址：[Baidu](www.baidu.com”百度一下，你就知道” )&lt;br&gt;实例：这就是我们常用的地址：&lt;a href=&quot;www.baidu.com&amp;quot;百度一下，你就知道&amp;quot;&quot;&gt;Baidu&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;列表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语法：使用 1. 2. 3. 表示有序列表，使用 * 或 - 或 + 表示无序列表&lt;br&gt;实例：&lt;br&gt;1.第一&lt;br&gt;2.第二&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;字体&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语法：使用 &lt;strong&gt; 或者 _ 表示粗体；\&lt;/strong&gt;字体&lt;strong&gt;  _字体_&lt;br&gt;实例：&lt;/strong&gt;字体**  &lt;em&gt;字体&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;转义&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转义使用反斜杠 \&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;空格&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在输入法切换到全角模式，输入空格即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二、印象层次&quot;&gt;&lt;a href=&quot;#二、印象层次&quot; class=&quot;headerlink&quot; title=&quot;二、印象层次&quot;&gt;&lt;/a&gt;二、印象层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除线&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语法： ~~ 表示删除线; \&lt;del&gt;中划线&lt;/del&gt;&lt;br&gt;实例：&lt;del&gt;中划线&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;标注&lt;/strong&gt;（略）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;三、了解层次&quot;&gt;&lt;a href=&quot;#三、了解层次&quot; class=&quot;headerlink&quot; title=&quot;三、了解层次&quot;&gt;&lt;/a&gt;三、了解层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流程图&lt;/strong&gt;（略）&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　作为一名合格的程序猿，写文档是必需的，选择一款合适的编辑器就如同一个好的助手，Markdown就是一个好的选择，语法简洁，逼格高~~，如果你经常玩GitHub，就会知道我们用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面就是基于Markdwon语法的。下面就来学习一下Markdown的基本语法吧！&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://www.jiang-yu.cn/categories/Markdown/"/>
    
    
      <category term="Markdown syntax" scheme="http://www.jiang-yu.cn/tags/Markdown-syntax/"/>
    
  </entry>
  
  <entry>
    <title>Linux下部署多个Tomcat的配置</title>
    <link href="http://www.jiang-yu.cn/2016/06/02/Linux/Linux%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AATomcat%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.jiang-yu.cn/2016/06/02/Linux/Linux下部署多个Tomcat配置/</id>
    <published>2016-06-02T13:58:51.000Z</published>
    <updated>2016-06-03T16:36:42.000Z</updated>
    
    <content type="html">&lt;p&gt;部署java项目时，经常需要配置多个Tomcat来运行多个应用，本文就简单的介绍一下如何来配置&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;方式一：全局配置&quot;&gt;&lt;a href=&quot;#方式一：全局配置&quot; class=&quot;headerlink&quot; title=&quot;方式一：全局配置&quot;&gt;&lt;/a&gt;方式一：全局配置&lt;/h3&gt;&lt;p&gt;　　如果是全局环境的安装就直接修改/etc目录下的profile文件，添加一组java环境变量，和两组CATALINA环境变量；修改后的profile文件示例如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib:$JAVA_HOME/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export JAVA_HOME CLASSPATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CATALINA_BASE=/u01/app/apache-tomcat-6.0.18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CATALINA_HOME=/u01/app/apache-tomcat-6.0.18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CATALINA_BASE CATALINA_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CATALINA_2_BASE=/u01/app/apache-tomcat-shanghai&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CATALINA_2_HOME=/u01/app/apache-tomcat-shanghai&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CATALINA_2_BASE CATALINA_2_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TOMCAT_HOME=/u01/app/apache-tomcat-6.0.18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export TOMCAT_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TOMCAT_2_HOME=/u01/app/apache-tomcat-shanghai&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export TOMCAT_2_HOME&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;方式二：临时配置方式&quot;&gt;&lt;a href=&quot;#方式二：临时配置方式&quot; class=&quot;headerlink&quot; title=&quot;方式二：临时配置方式&quot;&gt;&lt;/a&gt;方式二：临时配置方式&lt;/h3&gt;&lt;p&gt;　　第一个安装在/u01/app/apache-tomcat-6.0.18处的tomcat，保持解压后的原状不用修改。修改第二个安装在/u01/app/apache-tomcat-shanghai处的tomcat。需要修改两个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改server.xml配置和第一个不同的启动、关闭监听端口。修改后示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Server port=&amp;quot;8050&amp;quot; shutdown=&amp;quot;SHUTDOWN&amp;quot;&amp;gt;　 端口：8049-&amp;gt;8050&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- Define a non-SSL HTTP/1.1 Connector on port 8080 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Connector port=&amp;quot;9080&amp;quot; maxHttpHeaderSize=&amp;quot;8192&amp;quot;　&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     maxThreads=&amp;quot;150&amp;quot; minSpareThreads=&amp;quot;25&amp;quot; maxSpareThreads=&amp;quot;75&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     enableLookups=&amp;quot;false&amp;quot; redirectPort=&amp;quot;8443&amp;quot; acceptCount=&amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     connectionTimeout=&amp;quot;20000&amp;quot; disableUploadTimeout=&amp;quot;true&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改bin下的startup.sh和shutdown.sh。修改后的示例如下：（同样的修改）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export JAVA_HOME=/usr/jdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:$JAVA_HOME/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CLASSPATH=$JAVA_HOME/lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CATALINA_HOME=$CATALINA_2_HOME 利用profile中第二组设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CATALINA_BASE=$CATALINA_2_BASE 利用profile中第二组设置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;步骤三、重新加载一下资源文件&quot;&gt;&lt;a href=&quot;#步骤三、重新加载一下资源文件&quot; class=&quot;headerlink&quot; title=&quot;步骤三、重新加载一下资源文件&quot;&gt;&lt;/a&gt;步骤三、重新加载一下资源文件&lt;/h3&gt;&lt;p&gt;　　修改完毕后，source /etc/profile。&lt;br&gt;　　可能是因为修改了profile文件的缘故&lt;/p&gt;
&lt;p&gt;　　注意：如果是每个用户的配置，就需要到用户的目录下：/home/用户/下 ，执行ls -a 找出.bash_profile 修改以上东西即可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;部署java项目时，经常需要配置多个Tomcat来运行多个应用，本文就简单的介绍一下如何来配置&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.jiang-yu.cn/categories/Linux/"/>
    
    
      <category term="Linux，Tomcat" scheme="http://www.jiang-yu.cn/tags/Linux%EF%BC%8CTomcat/"/>
    
  </entry>
  
  <entry>
    <title>初识AngularJS</title>
    <link href="http://www.jiang-yu.cn/2016/06/02/AngularJS/%E5%88%9D%E8%AF%86AngularJS/"/>
    <id>http://www.jiang-yu.cn/2016/06/02/AngularJS/初识AngularJS/</id>
    <published>2016-06-02T13:47:51.000Z</published>
    <updated>2016-06-02T13:29:51.000Z</updated>
    
    <content type="html">&lt;p&gt;　　MVC只是手段，终极目标是模块化和复用&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、AngularJS和传统JavaScript的区别：&quot;&gt;&lt;a href=&quot;#一、AngularJS和传统JavaScript的区别：&quot; class=&quot;headerlink&quot; title=&quot;一、AngularJS和传统JavaScript的区别：&quot;&gt;&lt;/a&gt;一、AngularJS和传统JavaScript的区别：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;传统的JavaScript要求开发者对整个DOM结构都有所了解，并强迫我们在JavaScript代码中加入复杂的控制逻辑，用以操作外部DOM，而AngularJS则通过原生的Model-View-Controller（MVC，模型-视图-控制器）功能增强了HTML;&lt;/li&gt;
&lt;li&gt;使用AngularJS，开发者可以将页面的一部分封装为一个应用，并不强迫整个页面都使用AngularJS进行开发;&lt;/li&gt;
&lt;li&gt;AngularJS团队非常重视框架文件压缩后的大小，这样使用它就不会付出太多的额外代价;&lt;h3 id=&quot;二、使用AngularJS的第一个Web应用：&quot;&gt;&lt;a href=&quot;#二、使用AngularJS的第一个Web应用：&quot; class=&quot;headerlink&quot; title=&quot;二、使用AngularJS的第一个Web应用：&quot;&gt;&lt;/a&gt;二、使用AngularJS的第一个Web应用：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;html ng-app&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;title&amp;gt;Simple app &amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;script src=&amp;quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.2.13/angular.js&amp;quot;  &amp;lt;/script&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;/head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &amp;lt;input ng-model=&amp;quot;name&amp;quot; type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Your name&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;h1&amp;gt;Hello &amp;#123;&amp;#123; name &amp;#125;&amp;#125;&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;三、AngularJS中的数据绑定：&quot;&gt;&lt;a href=&quot;#三、AngularJS中的数据绑定：&quot; class=&quot;headerlink&quot; title=&quot;三、AngularJS中的数据绑定：&quot;&gt;&lt;/a&gt;三、AngularJS中的数据绑定：&lt;/h3&gt;&lt;p&gt;　　AngularJS创建实时模板来代替视图，而不是将数据合并进模板之后更新DOM。任何一个独立的视图组件中的值都是动态替换的。这个功能可以说是AngularJS中最重要的功能之一，这也是可以只用10行代码并且没有任何JavaScript的情况下写出一个Hello World.&lt;br&gt;　　a.　DOM元素上要明确设置ng-app属性&lt;br&gt;ng-app属性声明所有被其包含的内容都属于这个AngularJS应用，也就是说可以在Web应用中嵌套AngularJS应用的原因。&lt;br&gt;注意：只用被具有ng-app属性的DOM元素包含的元素才会受到AngularJS的影响。&lt;br&gt;　　b.　ng-app相当于main方法  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　MVC只是手段，终极目标是模块化和复用&lt;br&gt;
    
    </summary>
    
      <category term="AngularJS" scheme="http://www.jiang-yu.cn/categories/AngularJS/"/>
    
    
      <category term="AngularJS" scheme="http://www.jiang-yu.cn/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Filter和Inteceptor的区别-转载</title>
    <link href="http://www.jiang-yu.cn/2016/04/17/Spring/Spring%E4%B8%ADFilter%E5%92%8CInteceptor%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://www.jiang-yu.cn/2016/04/17/Spring/Spring中Filter和Inteceptor的区别-转载/</id>
    <published>2016-04-17T04:34:10.000Z</published>
    <updated>2016-06-02T13:34:36.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;原文出自：http://www.cnblogs.com/davidwang456/p/4108355.html
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;spring mvc DispatcherServlet详解之interceptor和filter的区别&lt;/p&gt;
&lt;p&gt;首先我们看一下spring mvc Interceptor的功能及实现：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=Mw3GaUhCRMhUFjU8iIDhObQpDcbmmRy_IPeumazg0ppnbmwqFUtLp9kSpuPPpeysf6EnHBLYFeWrbjqMq8BlWKQz_7MSDhGQTVl32fpxCMm&quot; title=&quot;Spring MVC Interceptor Introduce&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wenku.baidu.com/link?url=Mw3GaUhCRMhUFjU8iIDhObQpDcbmmRy_IPeumazg0ppnbmwqFUtLp9kSpuPPpeysf6EnHBLYFeWrbjqMq8BlWKQz_7MSDhGQTVl32fpxCMm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringMVC 中的Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理，其他的作用比如通过它来进行权限验证，或者是来判断用户是否登陆，日志记录，或者限制时间点访问。&lt;/p&gt;
&lt;p&gt;SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor 非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。&lt;/p&gt;
&lt;p&gt;HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。&lt;/p&gt;
&lt;p&gt;   （1 ）preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法。该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。&lt;/p&gt;
&lt;p&gt;   （2 ）postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。&lt;/p&gt;
&lt;p&gt;   （3 ）afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。 我们的系统日志的拦截在这个方法中，可以记录日志的相关的参数，检测方法的执行。&lt;/p&gt;
&lt;p&gt;在这里，我们就有一个疑问了：拦截器和过滤器到底有什么不同呢？&lt;/p&gt;
&lt;p&gt;首先，我们看一下官方是怎么解释的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface HandlerInterceptor
Workflow interface that allows for customized handler execution chains.
Applications can register any number of existing or custom interceptors for 
certain groups of handlers, to add common preprocessing behavior without 
needing to modify each handler implementation.
A HandlerInterceptor gets called before the appropriate HandlerAdapter triggers 
the execution of the handler itself. This mechanism can be used for a large field 
of preprocessing aspects, e.g. for authorization checks, or common handler behavior
like locale or theme changes. Its main purpose is to allow for factoring out repetitive 
handler code.

In an async processing scenario, the handler may be executed in a separate thread while 
the main thread exits without rendering or invoking the postHandle and afterCompletion 
callbacks. When concurrent handler execution completes, the request is dispatched 
back in order to proceed with rendering the model and all methods of this contract 
are invoked again. For further options and details 
see org.springframework.web.servlet.AsyncHandlerInterceptor

Typically an interceptor chain is defined per HandlerMapping bean, sharing its granularity. 
To be able to apply a certain interceptor chain to a group of handlers, one needs to map 
the desired handlers via one HandlerMapping bean. The interceptors themselves are defined 
as beans in the application context, referenced by the mapping bean definition 
via its &amp;quot;interceptors&amp;quot; property (in XML: a &amp;lt;list&amp;gt; of &amp;lt;ref&amp;gt;).

HandlerInterceptor is basically similar to a Servlet 2.3 Filter, but in contrast to the 
latter it just allows custom pre-processing with the option of prohibiting the execution 
of the handler itself, and custom post-processing. Filters are more powerful, for example 
they allow for exchanging the request and response objects that are handed down the chain. 
Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context.

As a basic guideline, fine-grained handler-related preprocessing tasks are candidates for 
HandlerInterceptor implementations, especially factored-out common handler code and authorization 
checks. On the other hand, a Filter is well-suited for request content and view content handling, 
like multipart forms and GZIP compression. This typically shows when one needs to map the filter 
to certain content types (e.g. images), or to all requests.


public interface Filter
A filter is an object that performs filtering tasks on either the request to a resource (a servlet or static content),
 or on the response from a resource, or both. 

Filters perform filtering in the doFilter method. Every Filter has access to a FilterConfig object from which it can 
obtain its initialization parameters, a reference to the ServletContext which it can use, for example, to load resources
needed for filtering tasks.

Filters are configured in the deployment descriptor of a web application

Examples that have been identified for this design are
1) Authentication Filters 
2) Logging and Auditing Filters 
3) Image conversion Filters 
4) Data compression Filters 
5) Encryption Filters 
6) Tokenizing Filters 
7) Filters that trigger resource access events 
8) XSL/T filters 
9) Mime-type chain Filter 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;interceptor 和filter的概念相似，但主要不同点有：&lt;/p&gt;
&lt;p&gt;web应用的过滤请求，仅使用web应用；&lt;/p&gt;
&lt;p&gt;interceptor应用于特定组别的handler，可以web应用也可以企业应用；&lt;/p&gt;
&lt;p&gt;从google找到的资料：&lt;a href=&quot;http://www.linkedin.com/groups/what-is-difference-between-interceptor-3983267.S.5844715100472107010&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.linkedin.com/groups/what-is-difference-between-interceptor-3983267.S.5844715100472107010&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Filter is used only in web applications whereas interceptor can be used with web as well as enterprise applications. 
Life cycle methods of both, also differs. The Interceptor stack fires on requests in a configured package while 
filters only apply to their mapped URL&amp;apos;s. 

Example: 

A Servlet Filter is used in the web layer only, you can&amp;apos;t use it outside of a 
web context. Interceptors can be used anywhere. 

The interceptor stack fires on every request. 
Filters only apply to the urls for which they are defined. 

Filters can be used when you want to modify any request or response parameters like headers. For example you would 
like to add a response header &amp;quot;Powered By Surya&amp;quot; to each generated response. Instead of adding this header in each 
resource method you would use a response filter to add this header. 

There are filters on the server side and the client side. 

In Summary: 

Filters: 

(1)Based on Servlet Specification 
(2)Executes on the pattern matches on the request. 
(3) Not configurable method calls. 


Interceptors: 
(1)Based on Struts2. 
(2)Executes for all the request qualifies for a front controller( A Servlet filter ).And can be configured to 
execute additional interceptor for a particular action execution. 
(3)Methods in the Interceptors can be configured whether to execute or not by means of excludemethods or includeMethods
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;原文出自：http://www.cnblogs.com/davidwang456/p/4108355.html
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Spring MVC" scheme="http://www.jiang-yu.cn/categories/Spring-MVC/"/>
    
    
      <category term="Filter" scheme="http://www.jiang-yu.cn/tags/Filter/"/>
    
      <category term="Inteceptor" scheme="http://www.jiang-yu.cn/tags/Inteceptor/"/>
    
  </entry>
  
  <entry>
    <title>Spring拦截器--HandlerInterceptorAdapter</title>
    <link href="http://www.jiang-yu.cn/2016/04/17/Spring/Spring%E6%8B%A6%E6%88%AA%E5%99%A8-HandlerInterceptorAdapter/"/>
    <id>http://www.jiang-yu.cn/2016/04/17/Spring/Spring拦截器-HandlerInterceptorAdapter/</id>
    <published>2016-04-17T03:49:35.000Z</published>
    <updated>2016-06-02T13:34:08.000Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;很多时候，在使用Spring要对某些请求进行过滤时候，我们首先想到的可能是Filte–过滤器，确实过滤器能够对请求进行过滤，实现对Bean的preHandle和postHandle。但是今天我们介绍另外的一种方式–拦截器（Interceptor）.在Spring MVC中拦截器不仅能够实现Filter的所有功能，而且对于需要进行拦截的请求可以更加自由的实现自定义的注入性。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、认识HandlerInterceptorAdapter&quot;&gt;&lt;a href=&quot;#一、认识HandlerInterceptorAdapter&quot; class=&quot;headerlink&quot; title=&quot;一、认识HandlerInterceptorAdapter&quot;&gt;&lt;/a&gt;一、认识HandlerInterceptorAdapter&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在spring中实现拦截器，需要继承HandlerInterceptorAdapter类，从类的名称可以看出，这是一个适配器类并且是抽象类，其提供了四个方法：【下面是Spring中的源码】&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
  * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.handler;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.AsyncHandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

/**
 * Abstract adapter class for the HandlerInterceptor interface,
 * for simplified implementation of pre-only/post-only interceptors.
 *
 * @author Juergen Hoeller
 * @since 05.12.2003
 */
public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor {

    /**
     * This implementation always returns {@code true}.
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {
        return true;
    }

    /**
     * This implementation is empty.
     */
    @Override
    public void postHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
            throws Exception {
    }

    /**
     * This implementation is empty.
     */
    @Override
    public void afterCompletion(
            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
            throws Exception {
    }

    /**
     * This implementation is empty.
     */
    @Override
    public void afterConcurrentHandlingStarted(
            HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;emsp;&amp;emsp;可以看出，这个抽象类提供的四个方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;preHandle  预处理–一般实现编码的控制和安全性控制&lt;/li&gt;
&lt;li&gt;postHandle 后处理–可以修改Spring中的ModelAndView,使得跳转到不同的View&lt;/li&gt;
&lt;li&gt;afterCompletion 返回处理–通过判断ex的值可以进行异常日志记录和处理&lt;/li&gt;
&lt;li&gt;afterConcurrentHandlingStarted&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;二、使用Spring-MVC-的拦截器&quot;&gt;&lt;a href=&quot;#二、使用Spring-MVC-的拦截器&quot; class=&quot;headerlink&quot; title=&quot;二、使用Spring MVC 的拦截器&quot;&gt;&lt;/a&gt;二、使用Spring MVC 的拦截器&lt;/h1&gt;&lt;p&gt;例如：我们可以使用拦截器实现特定情况下可以访问某些接口，最常用的情况是，某些系统提供给外部调用的接口需要有时间的限制。&lt;br&gt;    package com.jifenn.ja.web.common.interceptor;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Calendar;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;


/**
 * &amp;lt;p&amp;gt;功能描述&amp;lt;/br&amp;gt; 控制给外部系统调用某些接口的时间限制 : 接口开放时间：8：00-21：00 &amp;lt;/p&amp;gt;
 * 
 * @className Intf4OutCallTimeInterceptor
 * @author jiangyu
 * @date 2016年4月17日 下午12:18:25
 * @version v1.0
 */
public class Intf4OutCallTimeInterceptor extends HandlerInterceptorAdapter
{
    /** 允许时间段 **/
    private int allowTimeZone;

    /** 禁止时间段 **/
    private int forbidTimeZone;

    /** 需要拦截的路径 **/
    private String mappingRegexURL;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception
    {
        String url = request.getRequestURL().toString();
        if (mappingRegexURL == null || url.matches(mappingRegexURL))
        {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(new Date());
            int hour = calendar.get(Calendar.HOUR_OF_DAY);
            if (hour &amp;lt; allowTimeZone || hour &amp;gt; forbidTimeZone)
            {
                request.setAttribute(&amp;quot;msg&amp;quot;, &amp;quot;接口开放时间：8：00-21：00&amp;quot;);
                request.getRequestDispatcher(&amp;quot;/err.jsp&amp;quot;).forward(request, response);
                return false;
            }
            return true;
        }
        return true;
    }

    public void setAllowTimeZone(int allowTimeZone)
    {
        this.allowTimeZone = allowTimeZone;
    }

    public void setForbidTimeZone(int forbidTimeZone)
    {
        this.forbidTimeZone = forbidTimeZone;
    }

    public void setMappingRegexURL(String mappingRegexURL)
    {
        this.mappingRegexURL = mappingRegexURL;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;spring的xml配置文件配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;intf4OutAccessInterceptor&amp;quot; class=&amp;quot;com.jifenn.ja.web.common.interceptor.Intf4OutCallTimeInterceptor&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;allowTimeZone&amp;quot; value=&amp;quot;8&amp;quot; /&amp;gt;
    &amp;lt;property name=&amp;quot;forbidTimeZone&amp;quot; value=&amp;quot;21&amp;quot; /&amp;gt;
    &amp;lt;property name=&amp;quot;mappingRegexURL&amp;quot; value=&amp;quot;.*/intf4out\.do\?name=*&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean
    class=&amp;quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;interceptors&amp;quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;ref bean=&amp;quot;intf4OutAccessInterceptor&amp;quot; /&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;很多时候，在使用Spring要对某些请求进行过滤时候，我们首先想到的可能是Filte–过滤器，确实过滤器能够对请求进行过滤，实现对Bean的preHandle和postHandle。但是今天我们介绍另外的一种方式–拦截器（Interceptor）.在Spring MVC中拦截器不仅能够实现Filter的所有功能，而且对于需要进行拦截的请求可以更加自由的实现自定义的注入性。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring MVC" scheme="http://www.jiang-yu.cn/categories/Spring-MVC/"/>
    
    
      <category term="Interceptor" scheme="http://www.jiang-yu.cn/tags/Interceptor/"/>
    
  </entry>
  
  <entry>
    <title>git push error-- [rejected--non-fast-forward] 解决</title>
    <link href="http://www.jiang-yu.cn/2016/04/03/Git/git-push-rejected-non-fast-forward-Fixed/"/>
    <id>http://www.jiang-yu.cn/2016/04/03/Git/git-push-rejected-non-fast-forward-Fixed/</id>
    <published>2016-04-03T05:47:51.000Z</published>
    <updated>2016-06-02T13:32:23.000Z</updated>
    
    <content type="html">&lt;p&gt;在使用Eclipse插件egit将本地代码push到github时提示错误：&lt;br&gt;reject non - fast -forward&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;刚开始工作时，许多公司都还是喜欢用SVN来管理代码，但是作为一名“程序猿”，Git已经成为一项必备的技能，之前一直都对git有些冷落，最近由于有点想法–自己搞了点业余的项目练手，自己搭建SVN需要服务器（服务器~money,haha），所以就将代码搬到Git上。&lt;/p&gt;
&lt;p&gt;废话了这么多，回到正轨吧！首先，遇到上面的问题也是比较常见的，这里给出一种解决方法步骤（附图如下）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setp 1 :fetch 远程github中的工程

setp 2 :merge

setp 3 :push
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/4BhMdAh.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Eclipse插件egit将本地代码push到github时提示错误：&lt;br&gt;reject non - fast -forward&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.jiang-yu.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.jiang-yu.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>classpath,你真的理解了么？</title>
    <link href="http://www.jiang-yu.cn/2016/04/01/Spring/classpath-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%86%E4%B9%88%EF%BC%9F/"/>
    <id>http://www.jiang-yu.cn/2016/04/01/Spring/classpath-你真的理解了么？/</id>
    <published>2016-04-01T10:08:58.000Z</published>
    <updated>2016-06-02T13:32:55.000Z</updated>
    
    <content type="html">&lt;p&gt;CLASSPATH环境变量：作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPATH来寻找类的.class文件。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###CLASSPATH是什么？&lt;br&gt;在Java环境中，设置classpath的目的就是在于告诉Java执行环境（JVM）在哪个地方可以找到需要执行的Java程序所需要的类或者包。&lt;/p&gt;
&lt;p&gt;配置classpath其实就类似于c/c++中的#include&amp;lt;*.h&amp;gt;,就是将相应的要加载类引入。&lt;/p&gt;
&lt;p&gt;在Java Web项目中，classpath是指WEB-INF文件夹下的classes目录，将web应用发布到服务器时，会将src下所有的.java文件编译成字节码文件（*.class）和静态资源文件放入到WEB-INF目录下classes文件夹下。&lt;/p&gt;
&lt;p&gt;###classpath和classpath*的区别&lt;br&gt;classpath: 只会搜索当前项目中的class路径查找所需要的文件&lt;/p&gt;
&lt;p&gt;classpath*:不仅会搜索当前项目中的class路基查找所需要的文件，同时还会扫描所有的jar文件，加载所需要的文件。&lt;/p&gt;
&lt;p&gt;说明白点就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;classpath:会从第一个classpath中加载所需要的文件，而classpath*：会从所有的classpath中加载符合条件的文件；&lt;/li&gt;
&lt;li&gt;如果需要加载的资源不再当前的classLoader的路径中，用classpath：是获取不到该文件的（比如说是jar包中的配置文件），这种情况下就要使用classpath*:来加载相应的资源文件了；&lt;/li&gt;
&lt;li&gt;用classpath*:需要遍历所有的classpath,所以加载速度是很慢的，如果是在性能要求很高的系统中，还是不太建议这样去设计代码结构。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为最近在搭建项目的时候，遇到了这个问题，情景是这样的：搭建的web工程分成了几个模块，根据maven来管理项目，模块的包都打成jar包，最终呈现出来的是通过一个maven web工程打出一个war包，war包中是由几个模块打成的jar包组成，在项目启动的时候发现找不到jar包中的配置文件，因为我的配置就是classpath,后面网上查了一下资料，发现可以使用classpath*来实现。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CLASSPATH环境变量：作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPATH来寻找类的.class文件。&lt;br&gt;
    
    </summary>
    
      <category term="Spring MVC" scheme="http://www.jiang-yu.cn/categories/Spring-MVC/"/>
    
    
      <category term="classpath" scheme="http://www.jiang-yu.cn/tags/classpath/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket初识</title>
    <link href="http://www.jiang-yu.cn/2016/03/31/Websocket/WebSocket%E5%88%9D%E8%AF%86/"/>
    <id>http://www.jiang-yu.cn/2016/03/31/Websocket/WebSocket初识/</id>
    <published>2016-03-31T00:57:06.000Z</published>
    <updated>2016-06-02T13:35:06.000Z</updated>
    
    <content type="html">&lt;p&gt;  WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。【摘自百度百科】&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  WebSocket是为解决客户端与服务端实时通信而产生的技术。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，此后服务端与客户端通过此TCP连接进行实时通信。&lt;/p&gt;
&lt;p&gt;###一、WebSocket和Http协议的认识&lt;br&gt;首先Http协议是不支持长连接的，早期的HTTP1.0是没有所谓的keep-alive的，也就是只是一对一的通信，直到HTTP1.1才有keep-alive,就是把多个请求合并成一个，最终也只是几个请求对应几个响应，服务端不能主动的推送消息给客户端，而WebSocket其实是对HTTP协议的一种补充。&lt;/p&gt;
&lt;p&gt;###二、WebSocket和Http协议的区别&lt;br&gt;A.相对于Http协议来说，WebSocket是一个&lt;strong&gt;持久化&lt;/strong&gt;的协议，如果还是不是很清楚，可以看一下图片对比：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/i9c4TkV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出来，HTTP的生命周期是通过Request决定的，在HTTP 1.0中，每次通信只是一个request对应一个response，为了弥补这个问题，在HTTP 1.1协议中，增加了一个头部keep-alive，这个是保证连接保持的功能，虽然keep-alive能够保证同时发送多个请求，但是这其中有一个不变的规则就是有多少个请求（request）就有多少个响应(response),并且response是不会主动的向客户端推送消息的，是一种被动的方式。另外HTTP协议是一种无状态的协议，就是一旦浏览器关闭所有的信息都没有了。&lt;/p&gt;
&lt;p&gt;B.WebSocket协议是一种基于Html5的新的协议，但同时它也是基于Http协议的。&lt;/p&gt;
&lt;p&gt; 在WebSocket出现之前，为了实现实时信息的传递都是通过HTTP长轮询（Long Poll）的方式，或者ajax轮询的方式，或者其他的特殊方式。这两种方式都是服务器端被动的等待客户端来询问是否有新的信息，如果有新的信息来就处理，但是也有一些区别：&lt;/p&gt;
&lt;p&gt; Long Poll:客户端发起请求，如果服务端没有信息返回，客户端就一直等待服务端的响应，是一种阻塞式的请求方式。&lt;/p&gt;
&lt;p&gt; Ajax Pool：每隔一段时间就去请求一些服务器端，看是否有新的消息要处理。&lt;/p&gt;
&lt;p&gt; 从这两种方式来看，实现实时信息通信都非常耗资源。而WebSocket可以很好的利用有限的资源来实现上面的效果，先看下webSocket的请求模式：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://i.imgur.com/eRT4Mc6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 从上面的webSocket协议传输数据方式来看，只要每次建立一个HTTP连接，就可以不断的进行信息传输，并且不会再次发送HTTP连接了，也就是实现了正真意义上的长连接。&lt;/p&gt;
&lt;p&gt;###总结&lt;br&gt; websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信。在websocket出现之前，web交互一般是基于http协议的短连接或者长连接。websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”，这意味着一个websocket连接地址会是这样的写法：ws://**。websocket协议本质上是一个基于tcp的协议。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。【摘自百度百科】&lt;br&gt;
    
    </summary>
    
      <category term="WebSocket" scheme="http://www.jiang-yu.cn/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://www.jiang-yu.cn/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>mvc annotation-driven配置错误</title>
    <link href="http://www.jiang-yu.cn/2016/03/30/Spring/mvc%20annotation-driven%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF/"/>
    <id>http://www.jiang-yu.cn/2016/03/30/Spring/mvc annotation-driven配置错误/</id>
    <published>2016-03-30T03:43:22.000Z</published>
    <updated>2016-06-02T13:33:39.000Z</updated>
    
    <content type="html">&lt;p&gt;代码盲目的复制不是一个好的习惯，今天这个问题就是因为盲目的复制以前的代码，希望以后注意一点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;   今天用Spring MVC 做业余项目的时候，发现要自己手动的注册一个转换器（String字符串的乱码问题），发现在自定义StringHttpMessageConverter的时候（如下配置）&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://i.imgur.com/zPMWBEK.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;   发现项目启动的时候报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.xml.sax.SAXParseException; lineNumber: 28; columnNumber: 26; cvc-complex-type.2.1: 元素 &amp;apos;mvc:annotation-driven&amp;apos; 必须不含字符或元素信息项 [子级], 因为该类型的内容类型为空。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   根据错误提示信息可以定位到就是上面的配置项出现了问题，但是这种方式网上都有许多人说是可行的，自己感觉特别的疑惑，最后问度娘找到了一丝线索–spring 配置的xsd版本太低了，这个是老版本中规定的规则。&lt;/p&gt;
&lt;p&gt;   带着这么一个提示，我看了一下我自己spring使用的是4.1版本，但是spring的配置文件中使用的mvc命名空间中xsd的版本竟然是3.0版本.&lt;/p&gt;
&lt;p&gt;   果然，将3.0替换成4.0后项目能够正常启动了，String乱码问题也得到了解决。（如下图所示修改）&lt;br&gt;   &lt;img src=&quot;http://i.imgur.com/VtwCEbM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;提醒&quot;&gt;&lt;a href=&quot;#提醒&quot; class=&quot;headerlink&quot; title=&quot;提醒&quot;&gt;&lt;/a&gt;提醒&lt;/h3&gt;&lt;p&gt;   其实这也源于我们都喜欢拷代码，导致有些细节的问题没有注意到，这里也是给自己一个提醒吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;代码盲目的复制不是一个好的习惯，今天这个问题就是因为盲目的复制以前的代码，希望以后注意一点。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring MVC" scheme="http://www.jiang-yu.cn/categories/Spring-MVC/"/>
    
    
      <category term="Annotation-driven" scheme="http://www.jiang-yu.cn/tags/Annotation-driven/"/>
    
  </entry>
  
</feed>
