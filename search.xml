<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux修改系统默认启动模式]]></title>
      <url>http://www.jiang-yu.cn/2016/06/14/Linux/%E4%BF%AE%E6%94%B9Linux%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>　　为了避免每次开机都是进入到图形化界面，可以修改配置文件使得Linux默认为命令行模式启动。<br><a id="more"></a></p>
<p>　　下面有两种方式来实现：</p>
<ul>
<li><p>临时生效：在图形化界面下可以打开Terminal终端，切换到root用户，输入init3即可切换到命令行模式，如果要再次回到图形化界面，可以使用startx就可以了。</p>
</li>
<li><p>永久生效：修改 /etc/inittab  将启动模式修改为3<br>其中的数字可以设置为（0~6）<br>0 - 表示关闭系统（不要把默认设置成0）<br>1 - 单用户模式<br>2 - 多用户模式，没有NFS服务<br>3 - 多用户文本模式，是标准的运行级<br>5 - 图形模式<br>6 - 系统重新启动</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux关机操作命令]]></title>
      <url>http://www.jiang-yu.cn/2016/06/14/Linux/Linux%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>　　每天学一点Linux命令<br><a id="more"></a></p>
<blockquote>
<p>halt 立刻关机<br>poweroff 立刻关机<br>shutdown -h now 立刻关机(root用户使用)<br>shutdown -h 10 10分钟后自动关机<br>如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启<br>推荐使用shutdown命令</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VIM编辑器基础命令（一）]]></title>
      <url>http://www.jiang-yu.cn/2016/06/14/VIM/vim_command_01%20/</url>
      <content type="html"><![CDATA[<p>　　在Linux下操作文件，不会VIM命令那就犹如战士上战场没带枪，所以作为一个合格的程序猿，必须要对基本的VI命令非常熟练的使用，本文开始将记录一系列VI命令的使用，方便快速查阅。<br><a id="more"></a></p>
<ul>
<li>vi编辑器三种常用的模式：<br>　1.命令模式：就是用<code>vi/vim 文件名</code> 进入文件后的模式<br>　2.插入模式（i）：就是在命令模式下按下ｉ或者ａ即可进入<br>　3.ex（扩展）模式：就是使用’:xxxx’ 方式<br>　在任何一种模式下按Esc键都会回到命令模式</li>
<li>基础命令<ul>
<li><strong>命令模式</strong>：<br>  a　在光标后插入文本<br>  i　在光标前插入文本<br>  o　在当前行的下面插入新行<br>  dd　删除整行<br>  u　撤销上一操作<br>  yy　复制当前行<br>  p　粘贴<br>  n+yy　复制n行<br>  r　替换当前字符<br>  /　查找关键字，按n键在关键字之间进行切换</li>
<li><strong>扩展模式</strong>：<br>  :w　保存当前修改<br>  :q　退出<br>  :q!　强制退出，不保存修改<br>  :x　保存并退出，相当于:wq<br>  :set number　显示行号，或setnum<br>  :set nonumber　关闭行号显示</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ JMeter内存溢出解决办法]]></title>
      <url>http://www.jiang-yu.cn/2016/06/13/JMeter/JMeter%20OutOfMemory%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>　 最近用JMeter对Web进行压测，（JMeter也是用Java编写的一款工具）然而JMeter跑一段时间之后出现了内存溢出现象，问了下Google，虽然解决方式非常简单，但还是记录下来方便后面再次遇到就可以查找自己的知识库了！<br><a id="more"></a><br>　　为了应对618,要对我们的web应用进行压测，当然作为压测的工具首选是JMeter，因为它不大且不需要安装，配置也比较简单易懂。<br>　　在开始压测一段时间内是正常的，但是到运行到一定时间后就会出现，JMeter软件本身自己卡死，后台就一直报内存溢出的错误，如下图：<img src="/uploads/blog/JMeter/JMeter_OutOfMemory.png" alt="JMeter OutOfMemory"></p>
<p>Google结果是：修改JMeter.bat/JMeter.sh文件中的配置即可</p>
<ul>
<li><p><strong>windows</strong>环境下，修改jmeter.bat：<br><code>set HEAP=-Xms256m -Xmx256m
set NEW=-XX:NewSize=128m -XX:MaxNewSize=128m</code><br>改为：<br><code>set HEAP=-Xms256m -Xmx1024m
set NEW=-XX:NewSize=128m -XX:MaxNewSize=512m</code></p>
</li>
<li><p><strong>linux</strong>环境下，修改jmeter.sh：<br><code>java $JVM_ARGS -Xms1G -Xmx5G -XX:MaxPermSize=512m       -Dapple.laf.useScreenMenuBar=true -jar `dirname $0`/ApacheJMeter.jar &quot;$@&quot;</code></p>
</li>
</ul>
<p>　　由于我是在windows下测试，按照上面的配置，果然可以了，<del>^</del>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ MySql InnoDB Lock(二)--Intention Locks]]></title>
      <url>http://www.jiang-yu.cn/2016/06/04/MySQL/InnoDB/InnoDB_Intention_Lock/</url>
      <content type="html"><![CDATA[<p>　　在上一篇的<code>Shared And Exclusive Locks</code>中提及到InnoDB默认实现的是<code>Row-Level Lock</code>(行级锁)，同时InnoDB中也支持多种粒度类型的锁，本文介绍的<code>Intention Locks</code>（意向锁）就是一个体现，意向锁的主要目的是表明当前事务将要或者正在对表中的记录加锁。<br><a id="more"></a><br>　　在MySQL InnoDB引擎中的行级锁只有明确的指定主键的时候才会在被筛选记录(即：<code>where keyAttr(主键)=xxx</code>)上执行Row Lock，否则将会执行<br>Table Lock.</p>
<blockquote>
<p>摘抄自：MySql Doc</p>
<blockquote>
<p>InnoDB supports multiple granularity locking which permits coexistence of row-level locks and locks on entire tables. To make locking at multiple granularity levels practical, additional types of locks called intention locks are used. Intention locks are table-level locks in InnoDB that indicate which type of lock (shared or exclusive) a transaction will require later for a row in that table. There are two types of intention locks used in InnoDB (assume that transaction T has requested a lock of the indicated type on table t):</p>
</blockquote>
</blockquote>
<p>大概意思是：InnoDB引擎允许<code>Row Level</code> 锁和<code>Table Level</code> 锁 支持多粒度的锁,这种锁称作：<code>Intention Locks</code>,Intention Locks（意向锁）是属于Table Lock,它包含了两种类型：</p>
<ul>
<li>Intention shared(<em><strong>IS</strong></em>):<br>示例：Set an <em><strong>IS</strong></em> Locks :<code>SELECT ... LOCK IN SHARE MODE</code><br><strong>说明</strong>：事务在给一个数据行加共享锁之前必须先取得该表的IS锁</li>
<li>Intention exclusive(<em><strong>IX</strong></em>):<br>示例：Set an <em><strong>IX</strong></em> Locks ：<code>SELECT ... FOR UPDATE</code><br><strong>说明</strong>：事务在个一个数据行加排它锁之前必须先取得该表的IX锁<blockquote>
<p><strong>注意</strong>：<br>　　1.在一个事务获得表中一条记录的 <em><strong>S</strong></em> Lock 前必须首先获得一个<em><strong>IS</strong></em> Lock 或者更强的锁在表上；<br>　　2.在一个事务获得表中一条记录的 <em><strong>X</strong></em> LocK 前必须先获得一个<em><strong>IX</strong></em> Lock.</p>
</blockquote>
</li>
<li><p>InnoDB的锁类型相容性矩阵：<br> <img src="/uploads/blog/MySQL/InnoDB Lock Compatible.png" alt=""></p>
<blockquote>
<p>如果一个事务请求的锁模式和当前的锁兼容，InnoDB就将请求的锁授予给后开启的事务，否则后开启的事务就必须等待当前的锁释放才能获得锁。如果一个锁和一个存在的锁冲突了的并且一段时间都没有获取到锁的话，就会出现死锁（后面再介绍）的现象。</p>
</blockquote>
</li>
<li><p>死锁定义</p>
<blockquote>
<p>A situation where different transactions are unable to proceed, because each holds a lock that the other needs. Because both transactions are waiting for a resource to become available, neither will ever release the locks it holds.</p>
</blockquote>
</li>
<li><p>死锁的例子<br>&gt;<br>首先，客户A开启一个事务，然后对某一行执 IS 锁<br><code>START TRANSACTION;</code><br><code>select * from child where id=1 LOCK IN SHARE MODE;</code><br><small><strong>说明</strong>：取得<strong>IS</strong>锁</small><br>然后，客户B又过来开启了另外一个事务：<br><code>START TRANSACTION;</code><br>执行一个删除操作：<br><code>DELETE FROM child where id = 1;</code><br><small><strong>说明</strong>：此时由于需要<strong>X</strong> 锁，这个锁不兼容客户A持有的<strong>S</strong>锁，所以没有客户B没有获得<strong>X</strong>锁，一直等待A释放<strong>S</strong>锁，所以客户B就被一直阻塞</small><br>最后，客户A也执行删除操作：<br><code>DELETE FROM child where id = 1;</code><br>说明：此时客户A也需要X锁，而客户B也在等待X锁，此时InnoDB对客户A产生了一个死锁错误，并且终止其等待X锁操作。<br>结果客户端B抛出死锁：<br><code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></p>
</li>
</ul>
<ul>
<li>表级锁和行级锁的比较<br>&gt;<br>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ MySql InnoDB Lock(一)-- Shared and Exclusive Locks]]></title>
      <url>http://www.jiang-yu.cn/2016/06/04/MySQL/InnoDB/InnoDB_S_And_X_Lock/</url>
      <content type="html"><![CDATA[<p>　　InnoDB 引擎实现了两种标准的行级锁：共享锁(S锁)和排它锁(X锁),本篇就来介绍一下该类型的锁的相关信息。<br><a id="more"></a></p>
<p>###S Lock（共享锁） INTRODUCTION：</p>
<blockquote>
<p>A shared (S) lock permits the transaction that holds the lock to read a row.<br>基本的意思为：在开启事务读一行数据的时候允许拥有一个共享锁，所以共享锁也称为读锁（read lock）</p>
</blockquote>
<p>　　如果事务T1拥有S锁，其他独立的事务也可以同时获取S锁，也就是说S锁是共享的。</p>
<p>###X Lock（排它锁） INTRODUCTION：</p>
<blockquote>
<p>An exclusive (X) lock permits the transaction that holds the lock to update or delete a row.<br>基本的意思是：在开启事务更新或者删除一行数据的时候允许有一个排它锁，所以排它锁也称为写锁（write lock）</p>
</blockquote>
<p>　　如果事务T1拥有X锁，其他独立的事务T2如果需要获得X锁必须要等待事务T1释放锁之后才能够得到。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法整理]]></title>
      <url>http://www.jiang-yu.cn/2016/06/03/Markdown/MarkDown%E8%AF%AD%E6%B3%95%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>　　作为一名合格的程序猿，写文档是必需的，选择一款合适的编辑器就如同一个好的助手，Markdown就是一个好的选择，语法简洁，逼格高~~，如果你经常玩GitHub，就会知道我们用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面就是基于Markdwon语法的。下面就来学习一下Markdown的基本语法吧！<br><a id="more"></a></p>
<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><p>[TOC]<br>　　下面将从三个层次来展开讲解，首先是常用层次，就是我们平时用的最多的并且要牢牢记住的（就如写代码的第一步：基本语法的熟悉），然后是对于一些不常用的，但是有可能会用到的标记我们必须要有印象，用到的时候能够快速的回想起来，最后就是了解层次了，这些标记基本上很少用到，只是在特定的情况下可能用到，并且能够通过查阅资料使用即可。</p>
<h3 id="一、常用层次"><a href="#一、常用层次" class="headerlink" title="一、常用层次"></a>一、常用层次</h3><ul>
<li><strong>标题</strong></li>
</ul>
<blockquote>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
--- 次阶标题
=== 高阶标题
</code></pre><p><strong>注意</strong>：</p>
<ul>
<li><h1 id="和标题之间最好加一个空格"><a href="#和标题之间最好加一个空格" class="headerlink" title="和标题之间最好加一个空格"></a>和标题之间最好加一个空格</h1></li>
<li><h1 id="代表标题的层级，最多为六级"><a href="#代表标题的层级，最多为六级" class="headerlink" title="代表标题的层级，最多为六级"></a>代表标题的层级，最多为六级</h1></li>
</ul>
</blockquote>
<ul>
<li><strong>目录</strong><blockquote>
<p>　　在文档的标题都是按照Markdown语法来编写的，一般在一级标题下面使用 [TOC] 后会自动的生成层级目录。</p>
</blockquote>
</li>
<li><p>标签</p>
<blockquote>
<p> 标签使用如下标记：<br> 　　标签:Markdown<br> 　　Tags:Markdown</p>
</blockquote>
</li>
<li><p><strong>引用</strong></p>
<blockquote>
<p>使用 &gt; 表示引用， &gt;&gt; 表示引用里面再套一层引用，依次类推</p>
</blockquote>
</li>
<li><p><strong>图片</strong></p>
<blockquote>
<p>语法：![Beautiful](<a href="http://img1.imgtn.bdimg.com/it/u=2948830857,1878924554&amp;fm=21&amp;gp=0.jpg" target="_blank" rel="external">http://img1.imgtn.bdimg.com/it/u=2948830857,1878924554&amp;fm=21&amp;gp=0.jpg</a> “测试图片”)<br>实例：<img src="http://img1.imgtn.bdimg.com/it/u=2948830857,1878924554&amp;fm=21&amp;gp=0.jpg" alt="Beautiful" title="测试图片"></p>
</blockquote>
</li>
<li><p><strong>代码</strong></p>
<blockquote>
<p>使用<code>code content</code>,英文状态下的键盘的左上角~键即可输出”`”,连接三个中间输入代码，最后还是三个结束,如果是显示的是行内代码就用”``”</p>
</blockquote>
</li>
<li><p><strong>链接</strong></p>
<blockquote>
<p>语法：这就是我们常用的地址：[Baidu](www.baidu.com”百度一下，你就知道” )<br>实例：这就是我们常用的地址：<a href="www.baidu.com&quot;百度一下，你就知道&quot;">Baidu</a></p>
</blockquote>
</li>
<li><p><strong>列表</strong></p>
<blockquote>
<p>语法：使用 1. 2. 3. 表示有序列表，使用 * 或 - 或 + 表示无序列表<br>实例：<br>1.第一<br>2.第二</p>
</blockquote>
</li>
<li><p><strong>字体</strong></p>
<blockquote>
<p>语法：使用 <strong> 或者 _ 表示粗体；\</strong>字体<strong>  _字体_<br>实例：</strong>字体**  <em>字体</em></p>
</blockquote>
</li>
<li><p><strong>转义</strong></p>
<blockquote>
<p>转义使用反斜杠 \</p>
</blockquote>
</li>
<li><p><strong>空格</strong></p>
<blockquote>
<p>在输入法切换到全角模式，输入空格即可</p>
</blockquote>
</li>
</ul>
<h3 id="二、印象层次"><a href="#二、印象层次" class="headerlink" title="二、印象层次"></a>二、印象层次</h3><ul>
<li><p><strong>删除线</strong></p>
<blockquote>
<p>语法： ~~ 表示删除线; \<del>中划线</del><br>实例：<del>中划线</del></p>
</blockquote>
</li>
<li><p><strong>标注</strong>（略）</p>
</li>
</ul>
<h3 id="三、了解层次"><a href="#三、了解层次" class="headerlink" title="三、了解层次"></a>三、了解层次</h3><ul>
<li><strong>流程图</strong>（略）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下部署多个Tomcat的配置]]></title>
      <url>http://www.jiang-yu.cn/2016/06/02/Linux/Linux%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AATomcat%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>部署java项目时，经常需要配置多个Tomcat来运行多个应用，本文就简单的介绍一下如何来配置<br><a id="more"></a></p>
<h3 id="方式一：全局配置"><a href="#方式一：全局配置" class="headerlink" title="方式一：全局配置"></a>方式一：全局配置</h3><p>　　如果是全局环境的安装就直接修改/etc目录下的profile文件，添加一组java环境变量，和两组CATALINA环境变量；修改后的profile文件示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME CLASSPATH</span><br><span class="line">CATALINA_BASE=/u01/app/apache-tomcat-6.0.18</span><br><span class="line">CATALINA_HOME=/u01/app/apache-tomcat-6.0.18</span><br><span class="line">export CATALINA_BASE CATALINA_HOME</span><br><span class="line"></span><br><span class="line">CATALINA_2_BASE=/u01/app/apache-tomcat-shanghai</span><br><span class="line">CATALINA_2_HOME=/u01/app/apache-tomcat-shanghai</span><br><span class="line">export CATALINA_2_BASE CATALINA_2_HOME</span><br><span class="line">TOMCAT_HOME=/u01/app/apache-tomcat-6.0.18</span><br><span class="line">export TOMCAT_HOME</span><br><span class="line">TOMCAT_2_HOME=/u01/app/apache-tomcat-shanghai</span><br><span class="line">export TOMCAT_2_HOME</span><br></pre></td></tr></table></figure></p>
<h3 id="方式二：临时配置方式"><a href="#方式二：临时配置方式" class="headerlink" title="方式二：临时配置方式"></a>方式二：临时配置方式</h3><p>　　第一个安装在/u01/app/apache-tomcat-6.0.18处的tomcat，保持解压后的原状不用修改。修改第二个安装在/u01/app/apache-tomcat-shanghai处的tomcat。需要修改两个地方：</p>
<ul>
<li><p>修改server.xml配置和第一个不同的启动、关闭监听端口。修改后示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port=&quot;8050&quot; shutdown=&quot;SHUTDOWN&quot;&gt;　 端口：8049-&gt;8050</span><br><span class="line">&lt;!-- Define a non-SSL HTTP/1.1 Connector on port 8080 --&gt;</span><br><span class="line">&lt;Connector port=&quot;9080&quot; maxHttpHeaderSize=&quot;8192&quot;　</span><br><span class="line">     maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</span><br><span class="line">     enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;</span><br><span class="line">     connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改bin下的startup.sh和shutdown.sh。修改后的示例如下：（同样的修改）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">export CATALINA_HOME=$CATALINA_2_HOME 利用profile中第二组设置</span><br><span class="line">export CATALINA_BASE=$CATALINA_2_BASE 利用profile中第二组设置</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="步骤三、重新加载一下资源文件"><a href="#步骤三、重新加载一下资源文件" class="headerlink" title="步骤三、重新加载一下资源文件"></a>步骤三、重新加载一下资源文件</h3><p>　　修改完毕后，source /etc/profile。<br>　　可能是因为修改了profile文件的缘故</p>
<p>　　注意：如果是每个用户的配置，就需要到用户的目录下：/home/用户/下 ，执行ls -a 找出.bash_profile 修改以上东西即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识AngularJS]]></title>
      <url>http://www.jiang-yu.cn/2016/06/02/AngularJS/%E5%88%9D%E8%AF%86AngularJS/</url>
      <content type="html"><![CDATA[<p>　　MVC只是手段，终极目标是模块化和复用<br><a id="more"></a></p>
<h3 id="一、AngularJS和传统JavaScript的区别："><a href="#一、AngularJS和传统JavaScript的区别：" class="headerlink" title="一、AngularJS和传统JavaScript的区别："></a>一、AngularJS和传统JavaScript的区别：</h3><ol>
<li>传统的JavaScript要求开发者对整个DOM结构都有所了解，并强迫我们在JavaScript代码中加入复杂的控制逻辑，用以操作外部DOM，而AngularJS则通过原生的Model-View-Controller（MVC，模型-视图-控制器）功能增强了HTML;</li>
<li>使用AngularJS，开发者可以将页面的一部分封装为一个应用，并不强迫整个页面都使用AngularJS进行开发;</li>
<li>AngularJS团队非常重视框架文件压缩后的大小，这样使用它就不会付出太多的额外代价;<h3 id="二、使用AngularJS的第一个Web应用："><a href="#二、使用AngularJS的第一个Web应用：" class="headerlink" title="二、使用AngularJS的第一个Web应用："></a>二、使用AngularJS的第一个Web应用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">        &lt;html ng-app&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;title&gt;Simple app &lt;/title&gt;</span><br><span class="line">            &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.2.13/angular.js&quot;  &lt;/script&gt; </span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">             &lt;input ng-model=&quot;name&quot; type=&quot;text&quot; placeholder=&quot;Your name&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">        &lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三、AngularJS中的数据绑定："><a href="#三、AngularJS中的数据绑定：" class="headerlink" title="三、AngularJS中的数据绑定："></a>三、AngularJS中的数据绑定：</h3><p>　　AngularJS创建实时模板来代替视图，而不是将数据合并进模板之后更新DOM。任何一个独立的视图组件中的值都是动态替换的。这个功能可以说是AngularJS中最重要的功能之一，这也是可以只用10行代码并且没有任何JavaScript的情况下写出一个Hello World.<br>　　a.　DOM元素上要明确设置ng-app属性<br>ng-app属性声明所有被其包含的内容都属于这个AngularJS应用，也就是说可以在Web应用中嵌套AngularJS应用的原因。<br>注意：只用被具有ng-app属性的DOM元素包含的元素才会受到AngularJS的影响。<br>　　b.　ng-app相当于main方法  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring中Filter和Inteceptor的区别-转载]]></title>
      <url>http://www.jiang-yu.cn/2016/04/17/SpringMVC/Spring%E4%B8%ADFilter%E5%92%8CInteceptor%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%BD%AC%E8%BD%BD/</url>
      <content type="html"><![CDATA[<pre><code>原文出自：http://www.cnblogs.com/davidwang456/p/4108355.html
</code></pre><a id="more"></a>
<p>spring mvc DispatcherServlet详解之interceptor和filter的区别</p>
<p>首先我们看一下spring mvc Interceptor的功能及实现：</p>
<p><a href="http://wenku.baidu.com/link?url=Mw3GaUhCRMhUFjU8iIDhObQpDcbmmRy_IPeumazg0ppnbmwqFUtLp9kSpuPPpeysf6EnHBLYFeWrbjqMq8BlWKQz_7MSDhGQTVl32fpxCMm" title="Spring MVC Interceptor Introduce" target="_blank" rel="external">http://wenku.baidu.com/link?url=Mw3GaUhCRMhUFjU8iIDhObQpDcbmmRy_IPeumazg0ppnbmwqFUtLp9kSpuPPpeysf6EnHBLYFeWrbjqMq8BlWKQz_7MSDhGQTVl32fpxCMm</a></p>
<p>SpringMVC 中的Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理，其他的作用比如通过它来进行权限验证，或者是来判断用户是否登陆，日志记录，或者限制时间点访问。</p>
<p>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor 非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。</p>
<p>HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。</p>
<p>   （1 ）preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法。该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。</p>
<p>   （2 ）postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</p>
<p>   （3 ）afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。 我们的系统日志的拦截在这个方法中，可以记录日志的相关的参数，检测方法的执行。</p>
<p>在这里，我们就有一个疑问了：拦截器和过滤器到底有什么不同呢？</p>
<p>首先，我们看一下官方是怎么解释的：</p>
<pre><code>public interface HandlerInterceptor
Workflow interface that allows for customized handler execution chains.
Applications can register any number of existing or custom interceptors for 
certain groups of handlers, to add common preprocessing behavior without 
needing to modify each handler implementation.
A HandlerInterceptor gets called before the appropriate HandlerAdapter triggers 
the execution of the handler itself. This mechanism can be used for a large field 
of preprocessing aspects, e.g. for authorization checks, or common handler behavior
like locale or theme changes. Its main purpose is to allow for factoring out repetitive 
handler code.

In an async processing scenario, the handler may be executed in a separate thread while 
the main thread exits without rendering or invoking the postHandle and afterCompletion 
callbacks. When concurrent handler execution completes, the request is dispatched 
back in order to proceed with rendering the model and all methods of this contract 
are invoked again. For further options and details 
see org.springframework.web.servlet.AsyncHandlerInterceptor

Typically an interceptor chain is defined per HandlerMapping bean, sharing its granularity. 
To be able to apply a certain interceptor chain to a group of handlers, one needs to map 
the desired handlers via one HandlerMapping bean. The interceptors themselves are defined 
as beans in the application context, referenced by the mapping bean definition 
via its &quot;interceptors&quot; property (in XML: a &lt;list&gt; of &lt;ref&gt;).

HandlerInterceptor is basically similar to a Servlet 2.3 Filter, but in contrast to the 
latter it just allows custom pre-processing with the option of prohibiting the execution 
of the handler itself, and custom post-processing. Filters are more powerful, for example 
they allow for exchanging the request and response objects that are handed down the chain. 
Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context.

As a basic guideline, fine-grained handler-related preprocessing tasks are candidates for 
HandlerInterceptor implementations, especially factored-out common handler code and authorization 
checks. On the other hand, a Filter is well-suited for request content and view content handling, 
like multipart forms and GZIP compression. This typically shows when one needs to map the filter 
to certain content types (e.g. images), or to all requests.


public interface Filter
A filter is an object that performs filtering tasks on either the request to a resource (a servlet or static content),
 or on the response from a resource, or both. 

Filters perform filtering in the doFilter method. Every Filter has access to a FilterConfig object from which it can 
obtain its initialization parameters, a reference to the ServletContext which it can use, for example, to load resources
needed for filtering tasks.

Filters are configured in the deployment descriptor of a web application

Examples that have been identified for this design are
1) Authentication Filters 
2) Logging and Auditing Filters 
3) Image conversion Filters 
4) Data compression Filters 
5) Encryption Filters 
6) Tokenizing Filters 
7) Filters that trigger resource access events 
8) XSL/T filters 
9) Mime-type chain Filter 
</code></pre><p>interceptor 和filter的概念相似，但主要不同点有：</p>
<p>web应用的过滤请求，仅使用web应用；</p>
<p>interceptor应用于特定组别的handler，可以web应用也可以企业应用；</p>
<p>从google找到的资料：<a href="http://www.linkedin.com/groups/what-is-difference-between-interceptor-3983267.S.5844715100472107010" target="_blank" rel="external">http://www.linkedin.com/groups/what-is-difference-between-interceptor-3983267.S.5844715100472107010</a></p>
<pre><code>Filter is used only in web applications whereas interceptor can be used with web as well as enterprise applications. 
Life cycle methods of both, also differs. The Interceptor stack fires on requests in a configured package while 
filters only apply to their mapped URL&apos;s. 

Example: 

A Servlet Filter is used in the web layer only, you can&apos;t use it outside of a 
web context. Interceptors can be used anywhere. 

The interceptor stack fires on every request. 
Filters only apply to the urls for which they are defined. 

Filters can be used when you want to modify any request or response parameters like headers. For example you would 
like to add a response header &quot;Powered By Surya&quot; to each generated response. Instead of adding this header in each 
resource method you would use a response filter to add this header. 

There are filters on the server side and the client side. 

In Summary: 

Filters: 

(1)Based on Servlet Specification 
(2)Executes on the pattern matches on the request. 
(3) Not configurable method calls. 


Interceptors: 
(1)Based on Struts2. 
(2)Executes for all the request qualifies for a front controller( A Servlet filter ).And can be configured to 
execute additional interceptor for a particular action execution. 
(3)Methods in the Interceptors can be configured whether to execute or not by means of excludemethods or includeMethods
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring拦截器--HandlerInterceptorAdapter]]></title>
      <url>http://www.jiang-yu.cn/2016/04/17/SpringMVC/Spring%E6%8B%A6%E6%88%AA%E5%99%A8-HandlerInterceptorAdapter/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;很多时候，在使用Spring要对某些请求进行过滤时候，我们首先想到的可能是Filte–过滤器，确实过滤器能够对请求进行过滤，实现对Bean的preHandle和postHandle。但是今天我们介绍另外的一种方式–拦截器（Interceptor）.在Spring MVC中拦截器不仅能够实现Filter的所有功能，而且对于需要进行拦截的请求可以更加自由的实现自定义的注入性。</p>
<a id="more"></a>
<h1 id="一、认识HandlerInterceptorAdapter"><a href="#一、认识HandlerInterceptorAdapter" class="headerlink" title="一、认识HandlerInterceptorAdapter"></a>一、认识HandlerInterceptorAdapter</h1><p>&emsp;&emsp;在spring中实现拦截器，需要继承HandlerInterceptorAdapter类，从类的名称可以看出，这是一个适配器类并且是抽象类，其提供了四个方法：【下面是Spring中的源码】<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">   /*</span><br><span class="line">	 * Copyright 2002-2012 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package org.springframework.web.servlet.handler;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.AsyncHandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Abstract adapter class for the HandlerInterceptor interface,</span><br><span class="line"> * for simplified implementation of pre-only/post-only interceptors.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 05.12.2003</span><br><span class="line"> */</span><br><span class="line">public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * This implementation always returns &#123;@code true&#125;.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * This implementation is empty.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void postHandle(</span><br><span class="line">			HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * This implementation is empty.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void afterCompletion(</span><br><span class="line">			HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * This implementation is empty.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void afterConcurrentHandlingStarted(</span><br><span class="line">			HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看出，这个抽象类提供的四个方法：</p>
<ol>
<li>preHandle  预处理–一般实现编码的控制和安全性控制</li>
<li>postHandle 后处理–可以修改Spring中的ModelAndView,使得跳转到不同的View</li>
<li>afterCompletion 返回处理–通过判断ex的值可以进行异常日志记录和处理</li>
<li>afterConcurrentHandlingStarted</li>
</ol>
<h1 id="二、使用Spring-MVC-的拦截器"><a href="#二、使用Spring-MVC-的拦截器" class="headerlink" title="二、使用Spring MVC 的拦截器"></a>二、使用Spring MVC 的拦截器</h1><p>例如：我们可以使用拦截器实现特定情况下可以访问某些接口，最常用的情况是，某些系统提供给外部调用的接口需要有时间的限制。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.jifenn.ja.web.common.interceptor;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;功能描述&lt;/br&gt; 控制给外部系统调用某些接口的时间限制 : 接口开放时间：8：00-21：00 &lt;/p&gt;</span><br><span class="line"> * </span><br><span class="line"> * @className Intf4OutCallTimeInterceptor</span><br><span class="line"> * @author jiangyu</span><br><span class="line"> * @date 2016年4月17日 下午12:18:25</span><br><span class="line"> * @version v1.0</span><br><span class="line"> */</span><br><span class="line">public class Intf4OutCallTimeInterceptor extends HandlerInterceptorAdapter</span><br><span class="line">&#123;</span><br><span class="line">    /** 允许时间段 **/</span><br><span class="line">    private int allowTimeZone;</span><br><span class="line"></span><br><span class="line">    /** 禁止时间段 **/</span><br><span class="line">    private int forbidTimeZone;</span><br><span class="line"></span><br><span class="line">    /** 需要拦截的路径 **/</span><br><span class="line">    private String mappingRegexURL;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">        throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        if (mappingRegexURL == null || url.matches(mappingRegexURL))</span><br><span class="line">        &#123;</span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            calendar.setTime(new Date());</span><br><span class="line">            int hour = calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">            if (hour &lt; allowTimeZone || hour &gt; forbidTimeZone)</span><br><span class="line">            &#123;</span><br><span class="line">                request.setAttribute(&quot;msg&quot;, &quot;接口开放时间：8：00-21：00&quot;);</span><br><span class="line">                request.getRequestDispatcher(&quot;/err.jsp&quot;).forward(request, response);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAllowTimeZone(int allowTimeZone)</span><br><span class="line">    &#123;</span><br><span class="line">        this.allowTimeZone = allowTimeZone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setForbidTimeZone(int forbidTimeZone)</span><br><span class="line">    &#123;</span><br><span class="line">        this.forbidTimeZone = forbidTimeZone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMappingRegexURL(String mappingRegexURL)</span><br><span class="line">    &#123;</span><br><span class="line">        this.mappingRegexURL = mappingRegexURL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>spring的xml配置文件配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;intf4OutAccessInterceptor&quot; class=&quot;com.jifenn.ja.web.common.interceptor.Intf4OutCallTimeInterceptor&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;allowTimeZone&quot; value=&quot;8&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;forbidTimeZone&quot; value=&quot;21&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;mappingRegexURL&quot; value=&quot;.*/intf4out\.do\?name=*&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">	class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;interceptors&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;ref bean=&quot;intf4OutAccessInterceptor&quot; /&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git push error-- [rejected--non-fast-forward] 解决]]></title>
      <url>http://www.jiang-yu.cn/2016/04/03/GitHub/git-push-rejected-non-fast-forward-Fixed/</url>
      <content type="html"><![CDATA[<p>在使用Eclipse插件egit将本地代码push到github时提示错误：<br>reject non - fast -forward<br><a id="more"></a><br>刚开始工作时，许多公司都还是喜欢用SVN来管理代码，但是作为一名“程序猿”，Git已经成为一项必备的技能，之前一直都对git有些冷落，最近由于有点想法–自己搞了点业余的项目练手，自己搭建SVN需要服务器（服务器~money,haha），所以就将代码搬到Git上。</p>
<p>废话了这么多，回到正轨吧！首先，遇到上面的问题也是比较常见的，这里给出一种解决方法步骤（附图如下）：</p>
<pre><code>setp 1 :fetch 远程github中的工程

setp 2 :merge

setp 3 :push
</code></pre><p>如下图：</p>
<p><img src="http://i.imgur.com/4BhMdAh.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[classpath,你真的理解了么？]]></title>
      <url>http://www.jiang-yu.cn/2016/04/01/SpringMVC/classpath-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%86%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>CLASSPATH环境变量：作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPATH来寻找类的.class文件。<br><a id="more"></a></p>
<p>###CLASSPATH是什么？<br>在Java环境中，设置classpath的目的就是在于告诉Java执行环境（JVM）在哪个地方可以找到需要执行的Java程序所需要的类或者包。</p>
<p>配置classpath其实就类似于c/c++中的#include&lt;*.h&gt;,就是将相应的要加载类引入。</p>
<p>在Java Web项目中，classpath是指WEB-INF文件夹下的classes目录，将web应用发布到服务器时，会将src下所有的.java文件编译成字节码文件（*.class）和静态资源文件放入到WEB-INF目录下classes文件夹下。</p>
<p>###classpath和classpath*的区别<br>classpath: 只会搜索当前项目中的class路径查找所需要的文件</p>
<p>classpath*:不仅会搜索当前项目中的class路基查找所需要的文件，同时还会扫描所有的jar文件，加载所需要的文件。</p>
<p>说明白点就是：</p>
<ol>
<li>classpath:会从第一个classpath中加载所需要的文件，而classpath*：会从所有的classpath中加载符合条件的文件；</li>
<li>如果需要加载的资源不再当前的classLoader的路径中，用classpath：是获取不到该文件的（比如说是jar包中的配置文件），这种情况下就要使用classpath*:来加载相应的资源文件了；</li>
<li>用classpath*:需要遍历所有的classpath,所以加载速度是很慢的，如果是在性能要求很高的系统中，还是不太建议这样去设计代码结构。</li>
</ol>
<p>因为最近在搭建项目的时候，遇到了这个问题，情景是这样的：搭建的web工程分成了几个模块，根据maven来管理项目，模块的包都打成jar包，最终呈现出来的是通过一个maven web工程打出一个war包，war包中是由几个模块打成的jar包组成，在项目启动的时候发现找不到jar包中的配置文件，因为我的配置就是classpath,后面网上查了一下资料，发现可以使用classpath*来实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebSocket初识]]></title>
      <url>http://www.jiang-yu.cn/2016/03/31/Socket/WebScoket%E5%92%8CHttp%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<p>  WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。【摘自百度百科】<br><a id="more"></a><br>  WebSocket是为解决客户端与服务端实时通信而产生的技术。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，此后服务端与客户端通过此TCP连接进行实时通信。</p>
<p>###一、WebSocket和Http协议的认识<br>首先Http协议是不支持长连接的，早期的HTTP1.0是没有所谓的keep-alive的，也就是只是一对一的通信，直到HTTP1.1才有keep-alive,就是把多个请求合并成一个，最终也只是几个请求对应几个响应，服务端不能主动的推送消息给客户端，而WebSocket其实是对HTTP协议的一种补充。</p>
<p>###二、WebSocket和Http协议的区别<br>A.相对于Http协议来说，WebSocket是一个<strong>持久化</strong>的协议，如果还是不是很清楚，可以看一下图片对比：<br><img src="/uploads/blog/Socket/http_protocal.png" alt=""></p>
<p>从上图可以看出来，HTTP的生命周期是通过Request决定的，在HTTP 1.0中，每次通信只是一个request对应一个response，为了弥补这个问题，在HTTP 1.1协议中，增加了一个头部keep-alive，这个是保证连接保持的功能，虽然keep-alive能够保证同时发送多个请求，但是这其中有一个不变的规则就是有多少个请求（request）就有多少个响应(response),并且response是不会主动的向客户端推送消息的，是一种被动的方式。另外HTTP协议是一种无状态的协议，就是一旦浏览器关闭所有的信息都没有了。</p>
<p>B.WebSocket协议是一种基于Html5的新的协议，但同时它也是基于Http协议的。</p>
<p> 在WebSocket出现之前，为了实现实时信息的传递都是通过HTTP长轮询（Long Poll）的方式，或者ajax轮询的方式，或者其他的特殊方式。这两种方式都是服务器端被动的等待客户端来询问是否有新的信息，如果有新的信息来就处理，但是也有一些区别：</p>
<p> Long Poll:客户端发起请求，如果服务端没有信息返回，客户端就一直等待服务端的响应，是一种阻塞式的请求方式。</p>
<p> Ajax Pool：每隔一段时间就去请求一些服务器端，看是否有新的消息要处理。</p>
<p> 从这两种方式来看，实现实时信息通信都非常耗资源。而WebSocket可以很好的利用有限的资源来实现上面的效果，先看下webSocket的请求模式：</p>
<p> <img src="/uploads/blog/Socket/http_and_websocket.png" alt=""></p>
<p> 从上面的webSocket协议传输数据方式来看，只要每次建立一个HTTP连接，就可以不断的进行信息传输，并且不会再次发送HTTP连接了，也就是实现了正真意义上的长连接。</p>
<p>###总结<br> websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信。在websocket出现之前，web交互一般是基于http协议的短连接或者长连接。websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”，这意味着一个websocket连接地址会是这样的写法：ws://**。websocket协议本质上是一个基于tcp的协议。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mvc annotation-driven配置错误]]></title>
      <url>http://www.jiang-yu.cn/2016/03/30/SpringMVC/mvc%20annotation-driven%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<p>代码盲目的复制不是一个好的习惯，今天这个问题就是因为盲目的复制以前的代码，希望以后注意一点。</p>
<a id="more"></a>
<p>   今天用Spring MVC 做业余项目的时候，发现要自己手动的注册一个转换器（String字符串的乱码问题），发现在自定义StringHttpMessageConverter的时候（如下配置）</p>
<p>   <img src="/uploads/blog/Spring/spring-httpmessageconverter self-setting.png" alt=""><br>   发现项目启动的时候报错：</p>
<pre><code>org.xml.sax.SAXParseException; lineNumber: 28; columnNumber: 26; cvc-complex-type.2.1: 元素 &apos;mvc:annotation-driven&apos; 必须不含字符或元素信息项 [子级], 因为该类型的内容类型为空。
</code></pre><p>   根据错误提示信息可以定位到就是上面的配置项出现了问题，但是这种方式网上都有许多人说是可行的，自己感觉特别的疑惑，最后问度娘找到了一丝线索–spring 配置的xsd版本太低了，这个是老版本中规定的规则。</p>
<p>   带着这么一个提示，我看了一下我自己spring使用的是4.1版本，但是spring的配置文件中使用的mvc命名空间中xsd的版本竟然是3.0版本.</p>
<p>   果然，将3.0替换成4.0后项目能够正常启动了，String乱码问题也得到了解决。（如下图所示修改）<br>   <img src="/uploads/blog/Spring/spring-xsd version low.png" alt=""></p>
<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>   其实这也源于我们都喜欢拷代码，导致有些细节的问题没有注意到，这里也是给自己一个提醒吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat + Ngnix + Memcached 负载均衡 Session共享]]></title>
      <url>http://www.jiang-yu.cn/2016/03/06/Ngnix/Tomcat%20+%20Ngnix%20+%20Memcached%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%20Session%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>　　亲自动手实践和整理 Tomcat + Ngnix + Memcached 负载均衡 Session共享的实现<br><a id="more"></a></p>
<h2 id="目标：tomcat-ngnix-memcached-负载均衡-session共享"><a href="#目标：tomcat-ngnix-memcached-负载均衡-session共享" class="headerlink" title="目标：tomcat + ngnix + memcached 负载均衡 session共享"></a>目标：tomcat + ngnix + memcached 负载均衡 session共享</h2><h3 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h3><p><img src="/uploads/blog/Jdk/session_share_software_list.png" alt="准备安装软件"></p>
<h3 id="安装jdk环境"><a href="#安装jdk环境" class="headerlink" title="安装jdk环境"></a>安装jdk环境</h3><ul>
<li>解压jdk 压缩文件<br><code>tar -zxvf jdk-7u80-linux-x64.gz</code><br>建立Java目录 ，复制解压出来的jdk<br><img src="/uploads/blog/Jdk/config_java_temp_dir.png" alt="建立Java安装目录"></li>
<li><p>配置环境变量：</p>
<ul>
<li>编辑全局的配置文件<br><code>vim /etc/profile</code></li>
<li>在文件最后面加入如下配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#jdk configuration</span><br><span class="line">export JAVA_HOME=/home/jjyy/Public/java/jdk1.7/jdk1.7.0_80</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$CLASSPATH:.:$JER_HOME/lib:$JAVA_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　　使得配置立即生效<br>　　　<code>source /etc/profile</code><br>　　　检验Jdk环境是否配置：<br>　　　<code>echo $JAVA_HOME</code><br>　　　<img src="/uploads/blog/Jdk/check_jdk_config_success.png" alt="JDK_CONFG_CHECK"></p>
</li>
</ul>
<h3 id="安装tomcat-服务器"><a href="#安装tomcat-服务器" class="headerlink" title="安装tomcat 服务器"></a>安装tomcat 服务器</h3><ul>
<li>上传tomcat的压缩文件<br> <img src="/uploads/blog/Tomcat/upload_tomcat_software.png" alt="Upload_tomcat"></li>
<li>解压文件：（这里配置三个tomcat ）<br><code>tar -zxvf apache-tomcat-7.0.68.tar.gz</code><br><img src="/uploads/blog/Tomcat/tar_three_tomcat.png" alt="Upload_tomcat"></li>
<li><p>配置约定<br>因为要配置多个tomcat ，所以这里有必要规定一下三个tomcat配置的端口号不能够重复：</p>
<blockquote>
<p>tomcat7_8081　8081　8185　18443　8109<br> tomcat7_8082　8082　8285　28443　8209<br> tomcat7_8083　8083　8385　38443　8309</p>
</blockquote>
<p> 配置完成之后可以试一下<br> 如果遇到访问不到的问题，<br> 一、可能是tomcat配置的端口号有冲突<br> 二、linux的防火墙限制了（暂时可以将防火墙关掉）</p>
<p> 至此，tomcat的基本配置是完成了</p>
</li>
</ul>
<h3 id="安装ngnix"><a href="#安装ngnix" class="headerlink" title="安装ngnix"></a>安装ngnix</h3><ul>
<li><p>安装ngnix要准备一些依赖包和软件的安装<br><strong>A</strong>.<code>**Install gcc gcc-c++**</code><br><code>sudo yum install gcc
sudo yum install gcc-c++</code><br>由于本机（centos 6.5已经安装好了，可以演示一下，会提示是最新的版本，不需要安装）安装完成之后，进入安装openssl.<br><strong>B</strong>.<code>**Install openssl**</code><br>首先建立一个third文件夹，用来放置第三方依赖的应用<br>然后解压openssl-1.0.1s.tar.gz<br><code>tar -zxvf openssl-1.0.1s.tar.gz
cd openssl-1.0.1s
sudo ./config --prefix=/usr/local/openssl-1.0.1s
sudo make 
sudo make install</code><br><strong>C</strong>.<code>**Install pcre-8.37**</code><br>解压pcre-8.37.tar.gz<br><code>tar -zxvf pcre-8.37.tar.gz
cd pcre-8.37
sudo ./configure --prefix=/usr/local/pcre-8.37
sudo make
sudo make install</code><br>中途问题：<br><img src="/uploads/blog/Tomcat/error.png" alt="Upload_tomcat"><br><strong>解决方式</strong>：卸载旧版本升级新版本<br>查询当前版本：<br><code>rpm -qf /usr/bin/autoconf</code><br>卸载当前版本：<br><code>rpm -e --nodeps autoconf-2.63</code><br>升级最新版本：<br><code>tar -zxvf autoconf-2.68.tar.gz
sudo ./configure --prefix=/usr/
sudo make 
sudo make install</code><br><strong>D</strong>:<code>**Install zlib-1.2.8**</code><br>解压zlib-1.2.8.tar.gz<br><code>tar -zxvf zlib-1.2.8.tar.gz
sudo ./configure --prefix = /usr/local/zlib-1.2.8
cd zlib-1.2.8
sudo make 
sudo  make install</code><br>至此，安装ngnix需要依赖的包都安装好了，下面开始安装ngnix<br><strong>E</strong>.<code>**ngnix安装**</code><br>解压nginx-1.8.1.tar.gz<br><code>tar -zxvf nginx-1.8.1.tar.gz
cd nginx-1.8.1
sudo ./configure
--prefix=/usr/local/nginx-1.8.1.tar.gz \
--with-openssl=/home/jjyy/Public/third/openssl-1.0.1s \
--with-pcre=/home/jjyy/Public/third/pcre-8.37 \
--with-zlib=/home/jjyy/Public/third/zllib-1.2.8 \
--with-http_ssl_module
sudo make
sudo make install</code><br><img src="/uploads/blog/Ngnix/Ngnix_install_code.png" alt="Ngnix_install_code"><br>等待nginx安装完成之后，我们就可以开始ngnix的配置了：<br>首先要明白的是，我们使用的是三个tomcat来做负载均衡处理，所以我们要配置三个tomcat的路径映射：</p>
<pre><code>&gt;    server 127.0.0.1:8081 weight=5;
    server 127.0.0.1:8082 weight=5;
    server 127.0.0.1:8083 weight=5;
</code></pre><p>nginx监听的是80端口号,<br>下面就开始一步一步的配置nginx.conf配置文件：<br><img src="/uploads/blog/Ngnix/Ngnix_config.png" alt="Upload_tomcat"><br>这里是详细的配置：<br><code>[root@localhost conf]# vim nginx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">#创建进程的用户和用户组</span><br><span class="line">#user  nobody;</span><br><span class="line">user jjyy jjyy</span><br><span class="line">#服务进程数量 --一般等于cpu的个数</span><br><span class="line">worker_processes  1;</span><br><span class="line">#全局错误日志定义，建议开启error级别的日志</span><br><span class="line">error_log logs/error.log error;</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">#记录进程ID的文件</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">        #epoll 是多路复用IO中的一种方式，但是仅仅用于linux2.6以上的内核，可以大大的提升nginx的性能，linux建议使用epoll,FreeBSD建议使用kqueue</span><br><span class="line">        use epoll;</span><br><span class="line">        #一个worker_processe允许并发的连接数量</span><br><span class="line">        worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #http连接的持续时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    #gzip压缩设置</span><br><span class="line">    #gzip  on;</span><br><span class="line">        #开启gzip功能</span><br><span class="line">        gzip on;</span><br><span class="line">        #最小压缩的文件</span><br><span class="line">        gzip_min_length 1k;</span><br><span class="line">        #压缩缓冲区</span><br><span class="line">        gzip_buffers 4 16k;</span><br><span class="line">        #http协议的版本</span><br><span class="line">        gzip_http_version 1.1;</span><br><span class="line">        #gzip压缩比率，1压缩比最小处理速度最快，9压缩比最大但是处理速度最慢（传输快但是cpu使用率高）</span><br><span class="line">        gzip_comp_level 2;</span><br><span class="line">        #和http头有关系，加个vary头，给代理服务器使用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也进行压缩，所以根据客户端的HTTP头来判断是否需要进行压缩</span><br><span class="line">        gzip_vary on;</span><br><span class="line">        #gzip压缩类型，不用添加text/html，否则会报警告信息</span><br><span class="line">        gzip_types text/plain text/javascript text/css application/xml application/x-javascript application/json;</span><br><span class="line">    </span><br><span class="line">    #设定负载均衡的服务器的列表，可以设置多个upstream,但是mysvr名称要区别出来</span><br><span class="line">    upstream myClusterServer&#123;</span><br><span class="line">        #weight 表示权值，权值越高被分配到的机会就大</span><br><span class="line">        server 127.0.0.1:8081 weight=5;</span><br><span class="line">        server 127.0.0.1:8082 weight=5;</span><br><span class="line">        server 127.0.0.1:8083 weight=5;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        #nginx监听的端口号</span><br><span class="line">        listen       80;</span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        #字符编码</span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        charset utf-8;</span><br><span class="line">        #设定本虚拟机的访问日志。关闭日志可以减少IO,提高性能。</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            #定义服务器的默认网站根目录位置</span><br><span class="line">            root   html;</span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index  index.html index.htm index.jsp;</span><br><span class="line">            #请求转向myClusterServer定义的服务器列表</span><br><span class="line">            proxy_pass http://myClusterServer;</span><br><span class="line">            proxy_redirect default;</span><br><span class="line">            #根代理服务器连接的超时时间，必须要留意这个time out时间不能超过75秒，当一台服务器宕机时，过10秒转发到另外一台服务器上</span><br><span class="line">            proxy_connect_timeout 10;</span><br><span class="line">        &#125;</span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　配置文件配置好后，就启动nginx试一试：<br>　　上面的配置文件出现了点问题，修改如下<br>　　<img src="/uploads/blog/Ngnix/ngnix_config_error.png" alt="ngnix_config_error"><br>　　启动nginx：并且查看运行状态<br>　　<img src="/uploads/blog/Ngnix/start_ngnix_check_status.png" alt="start_ngnix_check_status"><br>　　查询监听的端口号：<br>　　<code>netstat -anop |grep 80</code><br>　　<img src="/uploads/blog/Ngnix/Ngnix_process_check.png" alt="Ngnix_process_check"><br>　　访问nginx 默认地址：192.168.159.129–自动的定向到了tomcat中至此，已经完成大部分 功能了，后面只剩下配置memcached来实现session共享了。</p>
<h3 id="配置Memcached-实现Session共享"><a href="#配置Memcached-实现Session共享" class="headerlink" title="配置Memcached 实现Session共享"></a>配置Memcached 实现Session共享</h3><p>　　首先我们要将memcached的服务给安装好，同理安装memcached需要依赖libevent安装包，所以我们先安装libevent包.</p>
<ul>
<li>安装libevent<br><code>tar -zxvf libevent-2.0.22-stable.tar.gz
cd libevent-2.0.22-stable
sudo ./configure --prefix=/usr/local/libevent-2.0.22-stable
sudo make
sudo make install</code>        </li>
<li>安装memcache<br><code>tar -zxvf memcached-1.4.25.tar.gz
cd memcached-1.4.25.tar.gz
sudo ./configure \
--prefix=/usr/local/memcached-1.4.25 \
--with-libevent=/usr/local/libevent-2.0.22-stable
sudo make
sudo make install</code><br>安装完成之后，使用 ./memcached -i 查看信息<br><img src="/uploads/blog/Memcache/Memcache_check_install.png" alt="Upload_tomcat"><br>然后启动memcached 服务：<br><code>sudo ./memcached -d -v -p 12000 -m 256 -u jjyy</code><br> 命令参数说明：<br> -d 以守护进程运行<br> -v 提示信息（在事件循环找打印错误、警告信息）<br> -p 端口号<br> -m 分配的内存<br> -u  用户<br> -l  监听的ip地址<br><img src="/uploads/blog/Memcache/Memcache_config_cmd_info.png" alt="Upload_tomcat"><br> 启动之后查看，<br> <code>ps -ef|grep memcached</code><br> <img src="/uploads/blog/Memcache/Memcache_run_check.png" alt="Upload_tomcat"><br> 也可以通过window 的telnet来检测是否开启了服务：<br> <img src="/uploads/blog/Memcache/Windows_client_check_status.png" alt="Upload_tomcat"><br> 至此，所有要配置的服务都配置好了，下面就需要整合tomcat和memcache 服务了</li>
</ul>
<h3 id="配置Tomcat-和Memcached-实现Session共享"><a href="#配置Tomcat-和Memcached-实现Session共享" class="headerlink" title="配置Tomcat 和Memcached 实现Session共享"></a>配置Tomcat 和Memcached 实现Session共享</h3><p>　　以tomcat7_8081配置为例，其他两个也类似：<br>　　具体操作如下：<br>　　首先要修改tomcat的server.xml 和context.xml<br>　　<code>server.xml</code><br>　　在Engine 节点添加属性：jvmRouter=”tomcatRouter8081”<br>　　<img src="/uploads/blog/Tomcat/Tomcat_config_route_flag.png" alt="Tomcat_config_route_flag"><br>　　<code>context.xml</code><br>　　在context 节点中加入配置项（Manager具体属性代表的意思请查看）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Manager</span><br><span class="line">    className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;</span><br><span class="line">    memcachedNodes=&quot;n1:127.0.0.1:12000&quot;</span><br><span class="line">    sticky=&quot;false&quot;</span><br><span class="line">    requestUriIgnorePattern=&quot;.*\.(png|gif|jpg|css|js|ico|jpeg)$&quot;</span><br><span class="line">    sessionBackupAsync=&quot;false&quot;</span><br><span class="line">    sessionBackupTimeout=&quot;100&quot;</span><br><span class="line">    transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　<img src="/uploads/blog/Tomcat/Tomcat_configroute_flag2.png" alt="Tomcat_configroute_flag2"><br>　　然后，将memcached实现session共享的依赖的jar包放入到tomcat的lib目录中，具体jar包需要到google下载（可以使用VPN,否则就想其他办法），需要的依赖如下图：<br>　　<img src="/uploads/blog/Tomcat/memcache_func_dependency.png" alt="memcache_func_dependency"><br>　　将这些jar包都扔到tomcat的lib目录中,到这里似乎是完成了，但是我们要实现session共享，我们就需要写一个简单的验证页面来测试我们的实验是否成功了：<br>　　将tomcat中默认的index.jsp替换掉【修改tomcat的webapp 中ROOT中的index.jsp】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;共享session测试【Tomcat+memcached】&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    SessionID:&lt;%=session.getId()%&gt;</span><br><span class="line">    &lt;BR&gt;</span><br><span class="line">    SessionIP:&lt;%=request.getServerName()%&gt;</span><br><span class="line">    &lt;BR&gt;</span><br><span class="line">    SessionPort:&lt;%=request.getServerPort()%&gt;</span><br><span class="line">    &lt;BR&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    out.println(&quot;This is Tomcat Server 8081.&quot;);</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　替换之后，启动三个tomcat,然后客户端去访问，查看是否sessionId是否相等，实验结果如下：<br>　　<img src="/uploads/blog/Tomcat/Session_share_Test.png" alt="Session_share_Test"><br>　　由上图可知，三个tomcat访问的SessionId都是一样的。<br>　　最后我们还可以测试一下负载均衡的实现：<br>　　访问服务器地址：192.168.159.129，多次刷新页面，看请求是不是机会均等的轮询访问：<br>　　第一次：<br>　　<img src="/uploads/blog/Tomcat/Visit_1.png" alt="Visit_1"><br>　　第二次：<br>　　<img src="/uploads/blog/Tomcat/Visit_2.png" alt="Visit_2"><br>　　第三次：<br>　　<img src="/uploads/blog/Tomcat/Visit_3.png" alt="Visit_3"><br>　　第四次：<br>　　<img src="/uploads/blog/Tomcat/Visit_4.png" alt="Visit_4"><br>　　第五次：<br>　　<img src="/uploads/blog/Tomcat/Visit_5.png" alt="Visit_5"><br>　　第六次：<br>　　<img src="/uploads/blog/Tomcat/Visit_6.png" alt="Visit_6"><br>　　第七次：<br>　　<img src="/uploads/blog/Tomcat/Visit_7.png" alt="Visit_7"><br>　　从上面的七次访问同一IP地址，通过nginx的轮询到不同的服务器中，而且每次的sessionID都是不同的，所以说这种方式对负载均衡也是实现了。<br>　　好了，写了这么多，要睡觉了，困死了，实践这些需要自己动手才会发现问题的所在，希望自己好好加油吧！</p>
]]></content>
    </entry>
    
  
  
</search>
